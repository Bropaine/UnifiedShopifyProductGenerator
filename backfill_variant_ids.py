"""
Shopify Variant ID Backfiller for Frontend Product Data
-------------------------------------------------------
This script is the second (post-import) step in a human-in-the-loop Shopify + static site workflow.

**Purpose:**
- To fetch newly generated Shopify variant IDs for each product after human CSV import,
  and backfill those IDs into the local `products.js` used by the static site frontend.

**Workflow:**
1. The human operator has uploaded a Shopify product CSV (generated by `main.py`), creating all products in Shopify.
2. Once products are live, this script:
    - Loads the local `products.js` (generated earlier by `main.py`).
    - Fetches all products and variants from Shopify via API.
    - Matches each local product to its Shopify variant using title and price (or other keys).
    - Updates each product’s `shopifyVariantId` field in-place.
    - Writes the updated `products.js` back to disk, ready for deployment to the static frontend.

**Key Principle:** - The human operator remains in the loop for data review, error handling, and upload timing. -
Automation ensures accurate linkage between static site and Shopify checkout without risking data mismatches or
overwrites.

**Note:** If the product matching fails (for example, if title or price have changed post-import), the human must
review and resolve any discrepancies."""

import os
import json
import requests
from dotenv import load_dotenv

# --- LOAD ENV ---
load_dotenv()
SHOPIFY_SHOP = os.getenv("SHOPIFY_SHOP")
SHOPIFY_TOKEN = os.getenv("SHOPIFY_TOKEN")

if not SHOPIFY_SHOP or not SHOPIFY_TOKEN:
    raise Exception("Set SHOPIFY_SHOP and SHOPIFY_TOKEN in your .env file.")


# --- READ products.js AND STRIP JS PREFIX ---
def load_products_js(filename):
    with open(filename, "r", encoding="utf-8") as f:
        raw = f.read().strip()
        # Find the first '[' and last ']' to extract the JSON array directly
        start = raw.find('[')
        end = raw.rfind(']')
        if start == -1 or end == -1 or start > end:
            raise Exception("Could not find JSON array in file.")
        json_str = raw[start:end + 1]
        return json.loads(json_str)


# --- WRITE products.js BACK (with window.products = prefix) ---
def write_products_js(products, filename):
    with open(filename, "w", encoding="utf-8") as f:
        f.write("window.products = ")
        json.dump(products, f, ensure_ascii=False, indent=2)
        f.write(";\n")


# --- FETCH ALL PRODUCTS FROM SHOPIFY ---
def get_all_shopify_products():
    products = []
    url = f"https://{SHOPIFY_SHOP}/admin/api/2024-04/products.json"
    headers = {
        "X-Shopify-Access-Token": SHOPIFY_TOKEN,
        "Content-Type": "application/json"
    }
    params = {"limit": 250}
    page = 1
    while True:
        print(f"Fetching page {page} of Shopify products...")
        resp = requests.get(url, headers=headers, params=params)
        data = resp.json()
        if "products" not in data:
            print("Error fetching products:", data)
            break
        batch = data["products"]
        products.extend(batch)
        if len(batch) < 250:
            break
        # Shopify REST API uses page_info for cursor pagination in recent versions
        # If needed, adapt here for >250 products
        page += 1
    return products


# --- MAIN LOGIC ---
def main():
    products_js_path = "products.js"
    products = load_products_js(products_js_path)
    print(f"Loaded {len(products)} products from {products_js_path}")

    shopify_products = get_all_shopify_products()
    print(f"Fetched {len(shopify_products)} Shopify products")

    # Build a handle → variant_id map (handle is the part before the first variant)
    shopify_map = {}
    for prod in shopify_products:
        # Variant info (assume only one per product)
        handle = prod["handle"]
        # Add all variants; use title/handle+salt to match perfectly
        for variant in prod.get("variants", []):
            # Use same logic as you did for handle (salted handle in your products.js is full 'id')
            # Find the salted handle in the 'sku' or another metafield (not available by default)
            # We have to match by name/price/tags/etc if salted handle is not available on Shopify.
            # Instead: match by product title and price for now.
            shopify_map[(prod["title"].strip(), float(variant["price"]))] = str(variant["id"])

    # Backfill each product in the JS file
    not_found = []
    updated = 0
    for p in products:
        key = (p["name"].strip(), float(p["price"]))
        variant_id = shopify_map.get(key)
        if variant_id:
            p["shopifyVariantId"] = variant_id
            updated += 1
        else:
            not_found.append(p["id"])
            print(f"Could not find variant for product: {p['name']} (id: {p['id']}, price: {p['price']})")

    write_products_js(products, products_js_path)
    print(f"Updated {updated} products with variant IDs.")
    if not_found:
        print(f"WARNING: {len(not_found)} products could not be matched and updated.")
        for pid in not_found:
            print(f" - {pid}")


if __name__ == "__main__":
    main()
