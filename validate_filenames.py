"""
Filename Validator for Shopify/Static Site Image Pipeline
---------------------------------------------------------
Checks a folder of product images for filename convention compliance:
- Ensures all required parts (category, title, price, etc.) are present
- Validates price field (must be float, non-negative)
- Flags invalid characters or illegal spaces
- Detects duplicate product titles or handles (by what the parser would generate)
- Strictly checks that (category, subcategory, ...) matches your site's nav/category paths
- Reports extra notes detected
- Prints a clear pass/fail summary and details per file

To use:
1. Place this script in your project folder (alongside `main.py`)
2. Place a `valid_category_paths.py` file in your project root containing a list called `VALID_CATEGORY_PATHS`
   (generated by your nav extraction script)
3. Run: `python validate_filenames.py path/to/folder`

Human stays in control: **no renaming or moving is performed.**
"""

import os
import sys
import hashlib
import difflib

# --- LOAD VALID CATEGORY PATHS ---
try:
    from Valid_Category_Paths.valid_category_paths import VALID_CATEGORY_PATHS
except ImportError:
    print("ERROR: Could not import VALID_CATEGORY_PATHS. "
          "Make sure a valid_category_paths.py file with a list called VALID_CATEGORY_PATHS exists.")
    sys.exit(1)

ACCEPTED_EXTENSIONS = {".jpg", ".jpeg", ".png"}
FORBID_CHARS = set(' !"#$%&\'()*,:;<=>?@[\\]^`{|}~')  # Allow hyphen/underscore/dot only

def parse_image_filename(filename):
    name = os.path.splitext(os.path.basename(filename))[0]
    parts = name.split('_')
    if len(parts) < 4:
        return None, "Too few underscore sections"
    # Find price (first float from end)
    price = None
    price_idx = None
    for i in range(len(parts) - 1, 0, -1):
        try:
            price = float(parts[i])
            price_idx = i
            break
        except ValueError:
            continue
    if price is None or price_idx is None:
        return None, "No valid price found"
    # Extra notes after price (if any)
    extra_notes = ""
    if price_idx < len(parts) - 1:
        extra_notes = "_".join(parts[price_idx + 1:]).replace('-', ' ')
    title_raw = parts[price_idx - 1]
    title = title_raw.replace('-', ' ').title()
    categories = parts[:price_idx - 1]
    if not categories:
        return None, "No category/subcategory fields found"
    base_handle = "-".join(parts[:price_idx]).lower()
    salt = hashlib.sha1(filename.encode()).hexdigest()[:6]
    handle = f"{base_handle}-{salt}"
    return {
        "handle": handle,
        "title": title,
        "price": price,
        "categories": categories,
        "extra_notes": extra_notes
    }, None

def find_close_path(cat_tuple):
    # Find closest valid paths using difflib
    # Only compare tuples of same length for meaningful suggestions
    matches = difflib.get_close_matches(
        '::'.join(cat_tuple),
        ['::'.join(t) for t in VALID_CATEGORY_PATHS if len(t) == len(cat_tuple)],
        n=2, cutoff=0.7)
    return [tuple(m.split('::')) for m in matches] if matches else []

def main(img_folder):
    print(f"Validating image filenames in: {img_folder}")
    all_files = [
        f for f in os.listdir(img_folder)
        if os.path.splitext(f)[1].lower() in ACCEPTED_EXTENSIONS
    ]
    if not all_files:
        print("No image files found in the folder!")
        return

    errors = []
    warnings = []
    handles_seen = set()
    titles_seen = set()
    for fname in sorted(all_files):
        # Check for forbidden characters
        justname = os.path.splitext(fname)[0]
        for c in justname:
            if c in FORBID_CHARS:
                errors.append((fname, f"Illegal character in filename: '{c}'"))
        # Parse using robust logic
        info, err = parse_image_filename(fname)
        if err:
            errors.append((fname, f"Parse error: {err}"))
            continue
        # Check price
        if info["price"] < 0.01:
            errors.append((fname, f"Price is zero or negative: {info['price']}"))
        # Check for duplicate handles/titles
        if info["handle"] in handles_seen:
            errors.append((fname, f"Duplicate product handle: {info['handle']}"))
        handles_seen.add(info["handle"])
        if info["title"].lower() in titles_seen:
            warnings.append((fname, f"Duplicate product title: {info['title']}"))
        titles_seen.add(info["title"].lower())
        # Warn on extra notes present
        if info["extra_notes"]:
            warnings.append((fname, f"Extra notes detected: {info['extra_notes']}"))
        # Strictly enforce category path matching
        cat_tuple = tuple([c.lower() for c in info["categories"]])
        if cat_tuple not in VALID_CATEGORY_PATHS:
            close = find_close_path(cat_tuple)
            suggestion = f" (Did you mean: {', '.join([' -> '.join(c) for c in close])})" if close else ""
            errors.append((fname, f"Category path {cat_tuple} not found in menu!{suggestion}"))

    # --- REPORT ---
    print("\n---- VALIDATION REPORT ----")
    if not errors and not warnings:
        print("All filenames PASSED validation!\n")
    else:
        for fname, err in errors:
            print(f"[ERROR]   {fname:40}  {err}")
        for fname, warn in warnings:
            print(f"[WARNING] {fname:40}  {warn}")
    print(f"\nSummary: {len(all_files)} files checked | {len(errors)} errors | {len(warnings)} warnings")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        img_folder = sys.argv[1]
    else:
        # Default to 'images' folder at project root
        img_folder = os.path.join(os.path.dirname(__file__), "images")
        print(f"No folder argument provided, defaulting to: {img_folder}")
    if not os.path.isdir(img_folder):
        print(f"Image folder not found: {img_folder}")
        sys.exit(1)
    main(img_folder)
