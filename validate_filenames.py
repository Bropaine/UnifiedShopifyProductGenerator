"""
Filename Validator for Shopify/Static Site Image Pipeline
---------------------------------------------------------
Checks a folder of product images for filename convention compliance:
- Ensures all required parts (category, title, price, etc.) are present
- Validates price field (must be float, non-negative)
- Flags invalid characters or illegal spaces
- Detects duplicate product titles or handles (by what the parser would generate)
- Strictly checks that (category, subcategory, ...) matches your site's nav/category paths
- Reports extra notes detected
- Prints a clear pass/fail summary and details per file

To use:
1. Place this script in your project folder (alongside `main.py`)
2. Place a `valid_category_paths.py` file in your project root containing a list called `VALID_CATEGORY_PATHS`
   (generated by your nav extraction script)
3. Run: `python validate_filenames.py path/to/folder`

Human stays in control: **no renaming or moving is performed.**

Shopify/Static Site Filename Validator â€” GUI Edition
----------------------------------------------------
Checks all image filenames in a selected folder for naming convention, valid category paths, duplicates, and more.

Instructions:
- Click 'Browse' to select the folder with your product images.
- Click 'Validate' to run checks.
- Errors, warnings, and a summary will be displayed.
- "Open Folder" opens the folder in your OS file manager.

Requires: valid_category_paths.py in Valid_Category_Paths/
"""

import os
import sys
import hashlib
import difflib
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext
import subprocess

# --- LOAD VALID CATEGORY PATHS ---
try:
    from Valid_Category_Paths.valid_category_paths import VALID_CATEGORY_PATHS
except ImportError:
    VALID_CATEGORY_PATHS = []
    # The GUI will error if run, but this allows code to load for editing.

ACCEPTED_EXTENSIONS = {".jpg", ".jpeg", ".png"}
FORBID_CHARS = set(' !"#$%&\'()*,:;<=>?@[\\]^`{|}~')  # Allow hyphen/underscore/dot only

def parse_image_filename(filename):
    name = os.path.splitext(os.path.basename(filename))[0]
    parts = name.split('_')
    if len(parts) < 4:
        return None, "Too few underscore sections"
    # Find price (first float from end)
    price = None
    price_idx = None
    for i in range(len(parts) - 1, 0, -1):
        try:
            price = float(parts[i])
            price_idx = i
            break
        except ValueError:
            continue
    if price is None or price_idx is None:
        return None, "No valid price found"
    # Extra notes after price (if any)
    extra_notes = ""
    if price_idx < len(parts) - 1:
        extra_notes = "_".join(parts[price_idx + 1:]).replace('-', ' ')
    title_raw = parts[price_idx - 1]
    title = title_raw.replace('-', ' ').title()
    categories = parts[:price_idx - 1]
    if not categories:
        return None, "No category/subcategory fields found"
    base_handle = "-".join(parts[:price_idx]).lower()
    salt = hashlib.sha1(filename.encode()).hexdigest()[:6]
    handle = f"{base_handle}-{salt}"
    return {
        "handle": handle,
        "title": title,
        "price": price,
        "categories": categories,
        "extra_notes": extra_notes
    }, None

def find_close_path(cat_tuple):
    matches = difflib.get_close_matches(
        '::'.join(cat_tuple),
        ['::'.join(t) for t in VALID_CATEGORY_PATHS if len(t) == len(cat_tuple)],
        n=2, cutoff=0.7)
    return [tuple(m.split('::')) for m in matches] if matches else []

def validate_folder(img_folder):
    results = []
    all_files = [
        f for f in os.listdir(img_folder)
        if os.path.splitext(f)[1].lower() in ACCEPTED_EXTENSIONS
    ]
    if not all_files:
        return "No image files found in the folder!\n", [], [], 0, 0, 0

    errors = []
    warnings = []
    handles_seen = set()
    titles_seen = set()
    for fname in sorted(all_files):
        # Check for forbidden characters
        justname = os.path.splitext(fname)[0]
        for c in justname:
            if c in FORBID_CHARS:
                errors.append((fname, f"Illegal character in filename: '{c}'"))
        # Parse using robust logic
        info, err = parse_image_filename(fname)
        if err:
            errors.append((fname, f"Parse error: {err}"))
            continue
        # Check price
        if info["price"] < 0.01:
            errors.append((fname, f"Price is zero or negative: {info['price']}"))
        # Check for duplicate handles/titles
        if info["handle"] in handles_seen:
            errors.append((fname, f"Duplicate product handle: {info['handle']}"))
        handles_seen.add(info["handle"])
        if info["title"].lower() in titles_seen:
            warnings.append((fname, f"Duplicate product title: {info['title']}"))
        titles_seen.add(info["title"].lower())
        # Warn on extra notes present
        if info["extra_notes"]:
            warnings.append((fname, f"Extra notes detected: {info['extra_notes']}"))
        # Strictly enforce category path matching
        cat_tuple = tuple([c.lower() for c in info["categories"]])
        if cat_tuple not in VALID_CATEGORY_PATHS:
            close = find_close_path(cat_tuple)
            suggestion = f" (Did you mean: {', '.join([' -> '.join(c) for c in close])})" if close else ""
            errors.append((fname, f"Category path {cat_tuple} not found in menu!{suggestion}"))
    report = ["\n---- VALIDATION REPORT ----"]
    if not errors and not warnings:
        report.append("All filenames PASSED validation!\n")
    else:
        for fname, err in errors:
            report.append(f"[ERROR]   {fname:40}  {err}")
        for fname, warn in warnings:
            report.append(f"[WARNING] {fname:40}  {warn}")
    summary = f"\nSummary: {len(all_files)} files checked | {len(errors)} errors | {len(warnings)} warnings"
    report.append(summary)
    return "\n".join(report), errors, warnings, len(all_files), len(errors), len(warnings)

class ValidatorGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Shopify/Static Site Filename Validator")
        self.geometry("780x500")
        self.folder = tk.StringVar()
        tk.Label(self, text="Step 1: Browse for your product image folder").pack(pady=5)
        frm = tk.Frame(self)
        frm.pack()
        tk.Entry(frm, textvariable=self.folder, width=60, state="readonly").pack(side="left", padx=2)
        tk.Button(frm, text="Browse", command=self.browse_folder).pack(side="left")
        tk.Button(frm, text="Open Folder", command=self.open_folder).pack(side="left", padx=5)
        tk.Label(self, text="Step 2: Click 'Validate' to check all image filenames").pack(pady=8)
        tk.Button(self, text="Validate", command=self.run_validation).pack()
        self.status = scrolledtext.ScrolledText(self, height=20, wrap="word", state="disabled", font=("Consolas", 10))
        self.status.pack(fill="both", expand=True, pady=10, padx=10)

    def browse_folder(self):
        folder = filedialog.askdirectory(title="Select folder with images")
        if folder:
            self.folder.set(folder)

    def open_folder(self):
        folder = self.folder.get()
        if not folder or not os.path.isdir(folder):
            messagebox.showerror("No folder", "No valid folder selected.")
            return
        if sys.platform == "win32":
            os.startfile(folder)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", folder])
        else:
            subprocess.Popen(["xdg-open", folder])

    def run_validation(self):
        folder = self.folder.get()
        if not folder or not os.path.isdir(folder):
            messagebox.showerror("No folder", "Please select a valid image folder.")
            return
        if not VALID_CATEGORY_PATHS:
            messagebox.showerror(
                "Missing valid_category_paths.py",
                "VALID_CATEGORY_PATHS not found. Make sure 'Valid_Category_Paths/valid_category_paths.py' exists."
            )
            return
        report, errors, warnings, total, nerr, nwarn = validate_folder(folder)
        self.status.config(state="normal")
        self.status.delete("1.0", "end")
        self.status.insert("end", report)
        self.status.see("end")
        self.status.config(state="disabled")
        if nerr == 0 and nwarn == 0:
            messagebox.showinfo("All Clear", "All files passed validation!\nReady to upload.")
        else:
            messagebox.showwarning("Validation complete",
                                   f"{nerr} errors, {nwarn} warnings.\nSee details in the report below.")

if __name__ == "__main__":
    ValidatorGUI().mainloop()
